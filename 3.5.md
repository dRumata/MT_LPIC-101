# 103.5 Create, monitor and kill processes

1. `oneko` - это симпатичная забавная программа, отображающая кошку, преследующую курсор мыши. Если она еще не установлена в вашей настольной системе, установите ее с помощью менеджера пакетов вашего дистрибутива. Мы будем использовать ее для изучения контроля выполнения заданий.

- Запустите программу. Как это сделать?
Набрав в терминале команду `oneko`.

- Переместите курсор мыши, чтобы увидеть, как кот преследует его. Теперь приостановите процесс. Как вы это сделаете? Каков будет результат?

Нажав комбинацию клавиш `Ctrl + z` :

```sh
[1]+ Stopped oneko
```

- Проверьте, сколько рабочих мест вы имеете в настоящее время. Что вы печатаете? Что получается на выходе?

```sh
$ jobs
[1]+ Stopped oneko
```

- Теперь отправьте его в фон, указав идентификатор задания. Каков будет результат? Как можно определить, что задание выполняется в фоновом режиме?

```sh
$ bg %1
[1]+ oneko &
```

Кошка снова двигается.

- Наконец, завершить работу, указав идентификатор задания. Что вы напечатаете?

```sh
$ kill %1
```

2. Узнайте PID всех процессов, порожденных веб-сервером Apache HTTPD (**apache2**), с помощью двух различных команд:

```sh
$ pgrep apache2
```
или
```sh
$ pidof apache2
```

3. Завершите все процессы **apache2** без использования их **PID** и с помощью двух разных команд:

```sh
$ pkill apache2
```

или

```sh
$ killall apache2
```

4. Предположим, вам нужно завершить работу всех экземпляров **apache2**, и у вас нет времени выяснять их **PID**. Как это сделать, используя `kill` с сигналом **SIGTERM** по умолчанию, в одной строке:

```sh
$ kill $(pgrep apache2)
$ kill `pgrep apache2`
```

или

```sh
$ kill $(pidof apache2)
$ kill `pidof apache2`
```

> ПРИМЕЧАНИЕ Поскольку **SIGTERM (15)** является сигналом по умолчанию, нет необходимости передавать какие-либо опции в `kill`.

5. Запустите `top` и взаимодействуйте с ним, выполняя следующие действия:

- Показать forest-вид процессов:

Нажмите `V`.

- Показать полные пути процессов с разграничением между пространством пользователя и пространством ядра:

Нажмите `c`.

6. Введите команду ps для отображения всех процессов, запущенных пользователем веб-сервера Apache HTTPD (**www-data**):

- Использование синтаксиса BSD:

```sh
$ ps U www-data
```

- Использование синтаксиса UNIX:

```sh
$ ps -u www-data
```

- Использование синтаксиса GNU:

```sh
$ ps --user www-data
```

7. Сигнал **SIGHUP** может быть использован для перезапуска некоторых демонов. Например, в веб-сервере Apache HTTPD отправка сигнала **SIGHUP** родительскому процессу (запущенному командой `init`) приводит к уничтожению его дочерних процессов. При этом родительский процесс перечитывает свои конфигурационные файлы, заново открывает файлы журналов и порождает новый набор дочерних процессов. Выполните следующие задачи:
   
- Запустите веб-сервер:

```sh
$ sudo systemctl start apache2
```

- Убедитесь, что вы знаете PID родительского процесса:

```sh
$ ps aux | grep apache2
```

Родительским процессом является процесс, запущенный пользователем root. В нашем случае это процесс с **PID 1653**.

- Заставьте веб-сервер Apache HTTPD перезагрузиться, послав ему сигнал **SIGHUP** в родительский процесс:

```sh
$ kill -SIGHUP 1653
```

- Проверьте, что родитель не был убит и что были порождены новые потомки:

```sh
$ ps aux | grep apache2
```

Теперь вы должны увидеть родительский процесс **apache2** вместе с двумя новыми дочерними процессами.

8. Хотя изначально вывод ps является статическим, его можно сделать динамическим, объединив `ps` и `watch`. Мы будем отслеживать веб-сервер Apache HTTPD на предмет новых подключений. Перед выполнением описанных ниже задач рекомендуется ознакомиться с описанием директивы **MaxConnectionsPerChild** в разделе **Apache MPM Common Directives**.

- Добавьте директиву **MaxConnectionsPerChild** со значением `1` в конфигурационный файл **apache2** - в Debian и производных она находится в файле **/etc/apache2/apache2.conf**; в семействе CentOS - в файле **/etc/httpd/conf/httpd.conf**. Не забудьте перезапустить **apache2**, чтобы изменения вступили в силу.
  
Строка, которую необходимо включить в конфигурационный файл, - `MaxConnectionsPerChild 1`. Одним из способов перезапуска веб-сервера является выполнение команды `sudo systemctl restart apache2`.

- Введите команду, использующую функции `watch`, `ps` и `grep` для поиска соединений **apache2**.

```sh
$ watch 'ps aux | grep apache2'
```

или

```sh
$ watch "ps aux | grep apache2"
```

- Теперь откройте веб-браузер или используйте браузер командной строки, например `lynx`, чтобы установить соединение с веб-сервером через его IP-адрес. Что вы наблюдаете в выводе программы `watch`?
Один из дочерних процессов, принадлежащих **www-data**, исчезает.

9. Как вы уже поняли, по умолчанию top сортирует задачи по проценту использования процессора в порядке убывания (более высокие значения - сверху). Это поведение можно изменить с помощью интерактивных клавиш `M` (использование памяти),` N` (уникальный идентификатор процесса), `T` (время работы) и `P` (процент использования процессора). Однако вы также можете отсортировать список задач по своему усмотрению, запустив `top` с ключом `-o` (более подробную информацию можно найти на man-странице `top`). Теперь выполните следующие действия:

- Запустите `top` так, чтобы задачи были отсортированы по использованию памяти:

```sh
$ top -o %MEM
```

- Убедитесь, что вы набрали правильную команду, выделив столбец памяти: Нажмите `x`.

10. В `ps` также имеется переключатель o для указания колонок, которые необходимо отобразить. Исследуйте этот вопрос и выполните следующие задачи:

- Запустите `ps` так, чтобы отображалась только информация о пользователе, проценте используемой памяти, проценте используемого процессорного времени и полной команде:

```sh
$ ps o user,%mem,%cpu,cmd
```

- Теперь запустите `ps` так, чтобы на экране отображалась только информация о пользователе и название используемых им программ:

```sh
$ ps o user,comm
```


11. Укажите, соответствуют ли следующие утверждения/функции **GNU Screen**, **tmux** или и тому, и другому:

| Характеристика/заявление                                                  | GNU Screen | tmux |
|---------------------------------------------------------------------------|:----------:|:----:|
| Префикс команды по умолчанию                                              |      v     |      |
| Client-Server Model                                                       |            |   v  |
| Панели являются псевдотерминалами                                         |            |   v  |
| Уничтожение региона не приводит к уничтожению связанное с ним окон (окна) |      v     |      |
| Сеансы включают в себя окна                                               |      v     |   v  |
| Сеансы могут быть отсоединены                                             |      v     |   v  |


12.  Установите на свой компьютер программу **GNU Screen** (имя пакета: **screen**) и выполните следующие задачи:

- Запустите программу. Какую команду вы используете?

`screen`

- Запустите `top`:

`top`

- Используя префикс-клавиши `screen`, откройте новое окно; затем откройте **/etc/screenrc** с помощью `vi`:

```
Ctrl + a - c
sudo vi /etc/screenrc
```

- Перечислите окна в нижней части экрана:

`Ctrl + a - w`

- Изменить имя текущего окна на `vi`:

`Ctrl + a - A` . Затем нужно набрать `vi` и нажать клавишу `Enter`.

- Измените название оставшегося окна на верхнее. Для этого сначала выведите список всех окон, чтобы можно было перемещаться вверх и вниз и выбрать нужное окно:

Сначала мы набираем `Ctrl + a - " `. Затем с помощью клавиш со стрелками отмечаем ту, где написано `0 bash` , и нажимаем `Enter` . Наконец, набираем `Ctrl + a - A` , вводим `top` и нажимаем `Enter` .

- Проверьте, что имена изменились, снова отобразив имена окон в нижней части экрана:
`Ctrl + a - w`

- Теперь отсоедините сессию и попросите screen создать новую сессию с именем `ssh`:
```sh
Ctrl + a - d 
screen -S "ssh"
```
and press `enter` .

- Отключитесь также от `ssh` и выведите на экран список сессий:
```sh
Ctrl + a - d 
screen -list 
# или
screen -ls`
```

- Теперь присоединитесь к первой сессии, используя ее PID:

```sh
screen -r PID-OF-SESSION
```

- Вы должны вернуться в верхнюю часть окна. Разделите окно по горизонтали и переместитесь в новую пустую область:

```
Ctrl + a - S
Ctrl + a - Tab
```

- Выведите на экран список всех окон и выберите vi для отображения в новой пустой области:

Используем `Ctrl + a - "`, чтобы отобразить все окна для выбора, отмечаем `vi` и нажимаем `Enter` .

- Теперь разделите текущую область по вертикали, переместитесь во вновь созданную пустую область и свяжите его с новым окном:

```
Ctrl + a - |
Ctrl + a - Tab
Ctrl + a - c
```

- Завершите работу всех регионов, кроме текущего (помните, что, хотя вы и убиваете регионы, окна все еще живы). Затем выйдите из всех окон текущего сеанса, пока не завершится сам сеанс:

```
Ctrl + a - Q . 
exit (для выхода из Bash) 
Shift + :  
```

затем набираем `quit` и нажимаем `Enter` (для выхода из `vi`). После этого набираем `exit` (для выхода из основной оболочки Bash) `q` (для завершения работы `top`); затем набираем `exit` (для выхода из основной оболочки Bash).

- Наконец, пусть `screen` еще раз перечислит свои сессии, убьет оставшуюся сессию `ssh` по **PID** и проверит, что сессий действительно не осталось:

```
screen -list or screen -ls
screen -S PID-OF-SESSION -X quit
screen -list or screen -ls
```

13. Установите на компьютер программу **tmux** (имя пакета: **tmux**) и выполните следующие задачи:

- Запустите программу. Какую команду вы используете?

```sh
tmux
```

- Запустите `top` (обратите внимание, как через пару секунд в строке состояния название окна меняется на **top**):

```sh
top
```

- Используя ключевой префикс `tmux`, откройте новое окно; затем создайте файл **~/.tmux.conf** с помощью `nano`:

```sh
Ctrl + b - c 
nano ~/.tmux.conf
```

- Разделите окно по вертикали и уменьшите размер вновь созданной панели в несколько раз:

```
Ctrl + b - "
Ctrl + b - Ctrl + ↓
```

- Теперь измените имя текущего окна на "Редактирование текста"; затем пусть `tmux` выведет список со всеми своими сессиями:

`Ctrl + b - ,` . Затем вводим новое имя и нажимаем клавишу `Enter` . `Ctrl + b - s` или `tmux ls`.

- Переход к верхнему окну и возврат к текущему окну осуществляется с помощью той же комбинации клавиш:

`Ctrl + b - n` или `Ctrl + b - p`

- Выход из текущей сессии и создание новой сессии, имя которой **ssh**, а имя ее окна - **ssh window**:

```sh
Ctrl + b - d 
tmux new -s "ssh" -n "ssh window"
```

- Отключитесь также от ssh-сессии и попросите `tmux` снова отобразить список сессий:

```sh
Ctrl + b - d 
tmux ls
```

> ПРИМЕЧАНИЕ С этого момента упражнение требует использования удаленной машины для ssh-подключений к локальному хосту (виртуальная машина вполне допустима и может оказаться очень практичной). Убедитесь, что на локальной машине установлен и работает openssh-сервер, а на удаленной машине установлен как минимум openssh-клиент.

- Теперь запустите удаленную машину и соединитесь по `ssh` с локальным хостом. После установления соединения проверьте наличие сеансов `tmux`:

На удаленном хосте: `ssh local-username@local-ipaddress`. После подключения к локальной машине: `tmux ls`.

- На удаленном хосте присоединитесь к сеансу **ssh** по имени:

```sh
tmux a -t ssh 
```
(`a` можно заменить на `at` или `attach`).

- Вернувшись на локальную машину, подключитесь к сеансу **ssh** по имени, убедившись, что соединение с удаленным узлом сначала прервано:

```
tmux a -d -t ssh
``` 
(`a` можно заменить на `at` или `attach`).

- Пусть все сессии отображаются для выбора, перейдите к первой сессии `[0]`. Там убейте сессию **ssh** по имени:

Набираем `Ctrl + b - s` , клавишами со стрелками отмечаем сессию `0` и нажимаем `Enter` 
```sh
tmux kill-session -t ssh
```

- Наконец, отсоединиться от текущей сессии и убить ее по имени:

```sh
Ctrl + b - d 
tmux kill-session -t 0
```

13. И `screen`, и `tmux` могут войти в режим командной строки через `командный префикс + :` (краткий пример с `tmux` мы уже рассматривали). Выполните некоторые исследования и следующие задачи в режиме командной строки:

- Заставить `screen` войти в режим копирования:

`Ctrl + a - :` — затем мы набираем copy.

- Заставить `tmux` переименовать текущее окно:

`Ctrl + b - :` — затем мы набираем rename-window.

- Заставить `screen` закрыть все окна и завершить сеанс:

`Ctrl + a - :` — затем мы набираем quit.

- Заставить `tmux` разделить панель на две части:

`Ctrl + b - :` — затем мы набираем split-window.

- Заставить `tmux` убить текущее окно:

`Ctrl + b - :` — затем мы набираем kill-window.

14. При переходе в режим копирования в экран можно использовать не только клавиши со стрелками и `PgUp` или `PgDown` для перемещения по текущему окну и буферу прокрутки. Имеется также возможность использования `vi`-подобного полноэкранного редактора. Используя этот редактор, выполните следующие задачи:

- Наберите в экранном терминале `echo supercalifragilisticexpialidocious`:

```sh
echo supercalifragilisticexpialidocious
```

- Теперь скопируйте пять последовательных символов (слева направо) в строке, расположенной прямо над курсором:

Входим в режим копирования: `Ctrl + a - [` или `Ctrl + a - :`, а затем набираем команду **"Копировать"**. Затем переходим на строку выше с помощью `k` и нажимаем `пробел`, чтобы отметить начало выделения. Наконец, переместимся на четыре символа вперед с помощью `l` и снова нажмем `пробел`, чтобы отметить конец выделения.

- Наконец, вставьте выделенное (stice) обратно в командную строку:

`Ctrl + a - ]`

15. Предположим, что вы хотите открыть доступ к сессии **tmux** (our_session) другому пользователю. Вы создали сокет (**/tmp/our_socket**) с нужными правами, чтобы и вы, и другой пользователь могли читать и писать. Какие еще два условия должны быть выполнены, чтобы второй пользователь смог успешно подключить сессию через `tmux -S /tmp/our_socket a -t our_session`?

Оба пользователя должны иметь общую группу, например, `multiplexer`. Тогда и сокет должен быть переведен в эту группу: 

```sh
chgrp multiplexer /tmp/our_socket
```