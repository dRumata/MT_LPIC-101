# 3. Команды GNU и UNIX

## 3.5 Процессы. Создание, мониторинг, завершение. (103.5 Create, monitor and kill processes)

### Вопросы для самопроверки

1. Укажите, соответствуют ли следующие утверждения/функции **GNU  Screen**, **tmux** или и тому, и другому:
   
| Характеристика/заявление                                                  | GNU Screen | tmux |
|---------------------------------------------------------------------------|:----------:|:----:|
| Префикс команды по умолчанию                                              |           |      |
| Client-Server Model                                                       |            |     |
| Панели являются псевдотерминалами                                         |            |     |
| Уничтожение региона не приводит к уничтожению связанное с ним окон (окна) |           |      |
| Сеансы включают в себя окна                                               |           |     |
| Сеансы могут быть отсоединены                                             |           |     |

<details>
<summary>Вариант ответа</summary>

| Характеристика/заявление                                                  | GNU Screen | tmux |
|---------------------------------------------------------------------------|:----------:|:----:|
| Префикс команды по умолчанию                                              |      v     |      |
| Client-Server Model                                                       |            |   v  |
| Панели являются псевдотерминалами                                         |            |   v  |
| Уничтожение региона не приводит к уничтожению связанное с ним окон (окна) |      v     |      |
| Сеансы включают в себя окна                                               |      v     |   v  |
| Сеансы могут быть отсоединены                                             |      v     |   v  |    

    
</details>
<br> 


2. Предположим, что вы хотите открыть доступ к сессии **tmux** (our_session) другому пользователю. Вы создали сокет (**/tmp/our_socket**) с нужными правами, чтобы и вы, и другой пользователь могли читать и писать. Какие еще два условия должны быть выполнены, чтобы второй пользователь смог успешно подключить сессию через `tmux -S /tmp/our_socket a -t our_session`?

<details>
<summary>Вариант ответа</summary>
Оба пользователя должны иметь общую группу, например, `multiplexer`. Тогда и сокет должен быть переведен в эту группу: 

```sh
chgrp multiplexer /tmp/our_socket
```
</details>
<br> 

---
### Практические задания
1. Узнайте PID всех процессов, порожденных веб-сервером Apache HTTPD (**httpd**), с помощью двух различных команд:

```sh
pgrep httpd
```
или
```sh
pidof httpd
```

---
2. Завершите все процессы **httpd** без использования их **PID** и с помощью двух разных команд:

2.1 Первый способ
```sh
pkill httpd
```
2.2 Запустите снова сервер httpd
```sh
sudo systemctl start httpd
```

и завершите процессы другим способом
```sh
killall httpd
```

---
3. Предположим, вам нужно завершить работу всех экземпляров **tail**, и у вас нет времени выяснять их **PID**. Как это сделать, используя `kill` с сигналом **SIGTERM** по умолчанию, в одной строке:

3.1 Подготовительный шаги:
```sh
history -a
tail -f .bash_history >newfile &
tail -f .bash_history >newfile2 &
```
3.2 Проверьте процессы
```sh
pgrep tail
```
3.3 Затем выполните одну из двух команд
```sh
kill $(pgrep tail)
kill `pgrep tail`
```
3.4 Проверьте процессы
```sh
pgrep tail
```

3.5 Подготовительный шаги:
```sh
history -a
tail -f .bash_history >newfile &
tail -f .bash_history >newfile2 &
```
3.6 Проверьте процессы
```sh
pidof tail
```
3.7 Затем выполните одну из двух команд

```sh
kill $(pidof tail)
kill `pidof tail`
```

> ПРИМЕЧАНИЕ Поскольку **SIGTERM (15)** является сигналом по умолчанию, нет необходимости передавать какие-либо опции в `kill`.

---
4. Запустите `top` и взаимодействуйте с ним, выполняя следующие действия:

4.1 Показать forest-вид процессов:

Нажмите `V`.

4.2 Показать полные пути процессов с разграничением между пространством пользователя и пространством ядра:

Нажмите `c`.

---
5. Введите команду ps для отображения всех процессов, запущенных пользователем веб-сервера Apache HTTPD (**apache**):

5.1 Использование синтаксиса BSD:

```sh
ps U apache
```

5.2 Использование синтаксиса UNIX:

```sh
ps -u apache
```

5.2 Использование синтаксиса GNU:

```sh
ps --user apache
```

---
6. Сигнал **SIGHUP** может быть использован для перезапуска некоторых демонов. Например, в веб-сервере Apache HTTPD отправка сигнала **SIGHUP** родительскому процессу (запущенному командой `init`) приводит к уничтожению его дочерних процессов. При этом родительский процесс перечитывает свои конфигурационные файлы, заново открывает файлы журналов и порождает новый набор дочерних процессов. Выполните следующие задачи:
   
6.1 Запустите веб-сервер:

```sh
sudo systemctl start httpd
```

6.2 Убедитесь, что вы знаете PID родительского процесса:

```sh
ps aux | grep httpd
```
```console
ps aux | grep httpd
root       16985  0.0  0.5  18200 11096 ?        Ss   12:33   0:00 /usr/sbin/httpd -DFOREGROUND
apache     16986  0.0  0.3  18272  6672 ?        S    12:33   0:00 /usr/sbin/httpd -DFOREGROUND
apache     16987  0.0  0.4 2419556 8620 ?        Sl   12:33   0:00 /usr/sbin/httpd -DFOREGROUND
apache     16988  0.0  0.4 2157460 8364 ?        Sl   12:33   0:00 /usr/sbin/httpd -DFOREGROUND
apache     16989  0.0  0.4 2222992 8364 ?        Sl   12:33   0:00 /usr/sbin/httpd -DFOREGROUND
```
Родительским процессом является процесс, запущенный пользователем root. В нашем случае это процесс с **PID 16985**.

6.3 Заставьте веб-сервер Apache HTTPD перезагрузиться, послав ему сигнал **SIGHUP** в родительский процесс:

```sh
sudo kill -SIGHUP 16985
```

6.4 Проверьте, что родитель не был убит и что были порождены новые потомки:

```sh
ps aux | grep httpd
```
```console
ps aux | grep httpd
root       16985  0.0  0.5  18200 11096 ?        Ss   12:33   0:00 /usr/sbin/httpd -DFOREGROUND
apache     17414  0.0  0.3  18740  6720 ?        S    12:39   0:00 /usr/sbin/httpd -DFOREGROUND
apache     17415  0.0  0.4 2222872 8520 ?        Sl   12:39   0:00 /usr/sbin/httpd -DFOREGROUND
apache     17416  0.0  0.4 2222872 8392 ?        Sl   12:39   0:00 /usr/sbin/httpd -DFOREGROUND
apache     17417  0.0  0.4 2354144 8648 ?        Sl   12:39   0:00 /usr/sbin/httpd -DFOREGROUND
student    17594  0.0  0.1   6360  2048 pts/1    S+   12:39   0:00 grep --color=auto httpd
```
Теперь вы должны увидеть родительский процесс **apache2** вместе с новыми дочерними процессами.

---
7. Хотя изначально вывод ps является статическим, его можно сделать динамическим, объединив `ps` и `watch`. Мы будем отслеживать веб-сервер Apache HTTPD на предмет новых подключений. Перед выполнением описанных ниже задач рекомендуется ознакомиться с описанием директивы **MaxConnectionsPerChild** в разделе **Apache MPM Common Directives**.

7.1 Добавьте директиву **MaxConnectionsPerChild** со значением `1` в конфигурационный файл **apache2** - в Debian и производных она находится в файле **/etc/apache2/apache2.conf**; в семействе CentOS - в файле **/etc/httpd/conf/httpd.conf**. Не забудьте перезапустить **httpd**, чтобы изменения вступили в силу.
  
Строка, которую необходимо включить в конфигурационный файл, - 
```json
MaxConnectionsPerChild 1
```
Одним из способов перезапуска веб-сервера является выполнение команды 
```sh
sudo systemctl restart httpd
```

7.2 Введите команду, использующую функции `watch`, `ps` и `grep` для поиска соединений **httpd**.

```sh
watch 'ps aux | grep httpd'
```

или

```sh
watch "ps aux | grep apache"
```

7.3 Теперь откройте веб-браузер или используйте браузер командной строки, например `lynx`, чтобы установить соединение с веб-сервером через его IP-адрес. Что вы наблюдаете в выводе программы `watch`?
Один из дочерних процессов, принадлежащих **httpd**, исчезает.

---
8. Как вы уже поняли, по умолчанию top сортирует задачи по проценту использования процессора в порядке убывания (более высокие значения - сверху). Это поведение можно изменить с помощью интерактивных клавиш `M` (использование памяти),` N` (уникальный идентификатор процесса), `T` (время работы) и `P` (процент использования процессора). Однако вы также можете отсортировать список задач по своему усмотрению, запустив `top` с ключом `-o` (более подробную информацию можно найти на man-странице `top`). Теперь выполните следующие действия:

8.1 Запустите `top` так, чтобы задачи были отсортированы по использованию памяти:

```sh
top -o %MEM
```

8.2 Убедитесь, что вы набрали правильную команду, выделив столбец памяти: Нажмите `x`.

---
9. В `ps` также имеется переключатель o для указания колонок, которые необходимо отобразить. Исследуйте этот вопрос и выполните следующие задачи:

9.1 Запустите `ps` так, чтобы отображалась только информация о пользователе, проценте используемой памяти, проценте используемого процессорного времени и полной команде:

```sh
ps o user,%mem,%cpu,cmd
```

9.2 Теперь запустите `ps` так, чтобы на экране отображалась только информация о пользователе и название используемых им программ:

```sh
ps o user,comm
```

---
10.  Установите на свой компьютер программу **GNU Screen** (имя пакета: **screen**) и выполните следующие задачи:

10.1 Запустите программу. Какую команду вы используете?

```sh
screen
```

10.2 Запустите `top`:

```sh
top
```

10.3 Используя префикс-клавиши `screen`, откройте новое окно; затем откройте **/etc/screenrc** с помощью `vi`:

```
Ctrl + a - c
sudo vi /etc/screenrc
```

10.4 Перечислите окна в нижней части экрана:

`Ctrl + a - w`

10.5 Изменить имя текущего окна на `vi`:

`Ctrl + a - A` . Затем нужно набрать `vi` и нажать клавишу `Enter`.

10.6 Измените название оставшегося окна на верхнее. Для этого сначала выведите список всех окон, чтобы можно было перемещаться вверх и вниз и выбрать нужное окно:

Сначала мы набираем `Ctrl + a - " `. Затем с помощью клавиш со стрелками отмечаем ту, где написано `0 bash` , и нажимаем `Enter` . Наконец, набираем `Ctrl + a - A` , вводим `top` и нажимаем `Enter` .

10.7 Проверьте, что имена изменились, снова отобразив имена окон в нижней части экрана:
`Ctrl + a - w`

10.8 Теперь отсоедините сессию и попросите screen создать новую сессию с именем `ssh`:
```sh
Ctrl + a - d 
screen -S "ssh"
```
и нажмите `enter` .

10.9 Отключитесь также от `ssh` и выведите на экран список сессий:
```sh
Ctrl + a - d 
screen -list 
# или
screen -ls`
```

10.10 Теперь присоединитесь к первой сессии, используя ее PID:

```sh
screen -r PID-OF-SESSION
```

10.11 Вы должны вернуться в верхнюю часть окна. Разделите окно по горизонтали и переместитесь в новую пустую область:

```
Ctrl + a - S
Ctrl + a - Tab
```

10.12 Выведите на экран список всех окон и выберите vi для отображения в новой пустой области:

Используем `Ctrl + a - "`, чтобы отобразить все окна для выбора, отмечаем `vi` и нажимаем `Enter` .

10.13 Теперь разделите текущую область по вертикали, переместитесь во вновь созданную пустую область и свяжите его с новым окном:

```
Ctrl + a - |
Ctrl + a - Tab
Ctrl + a - c
```

10.14 Завершите работу всех регионов, кроме текущего (помните, что, хотя вы и убиваете регионы, окна все еще живы). Затем выйдите из всех окон текущего сеанса, пока не завершится сам сеанс:

```
Ctrl + a - Q . 
exit (для выхода из Bash) 
Shift + :  
```

затем набираем `quit` и нажимаем `Enter` (для выхода из `vi`). После этого набираем `exit` (для выхода из основной оболочки Bash) `q` (для завершения работы `top`); затем набираем `exit` (для выхода из основной оболочки Bash).

10.15 Наконец, пусть `screen` еще раз перечислит свои сессии, убьет оставшуюся сессию `ssh` по **PID** и проверит, что сессий действительно не осталось:

```
screen -list or screen -ls
screen -S PID-OF-SESSION -X quit
screen -list or screen -ls
```

---
11. Установите на компьютер программу **tmux** (имя пакета: **tmux**) и выполните следующие задачи:

11.1 Запустите программу. Какую команду вы используете?

```sh
tmux
```

11.2 Запустите `top` (обратите внимание, как через пару секунд в строке состояния название окна меняется на **top**):

```sh
top
```

11.3 Используя ключевой префикс `tmux`, откройте новое окно; затем создайте файл **~/.tmux.conf** с помощью `nano`:

```sh
Ctrl + b - c 
nano ~/.tmux.conf
```

11.4 Разделите окно по вертикали и уменьшите размер вновь созданной панели в несколько раз:

```
Ctrl + b - "
Ctrl + b - Ctrl + ↓
```

11.5 Теперь измените имя текущего окна на "Редактирование текста"; затем пусть `tmux` выведет список со всеми своими сессиями:

`Ctrl + b - ,` . Затем вводим новое имя и нажимаем клавишу `Enter` . `Ctrl + b - s` или `tmux ls`.

11.6 Переход к верхнему окну и возврат к текущему окну осуществляется с помощью той же комбинации клавиш:

`Ctrl + b - n` или `Ctrl + b - p`

11.7 Выход из текущей сессии и создание новой сессии, имя которой **ssh**, а имя ее окна - **ssh window**:

```sh
Ctrl + b - d 
tmux new -s "ssh" -n "ssh window"
```

11.8 Отключитесь также от ssh-сессии и попросите `tmux` снова отобразить список сессий:

```sh
Ctrl + b - d 
tmux ls
```

> ПРИМЕЧАНИЕ С этого момента упражнение требует использования удаленной машины для ssh-подключений к локальному хосту (виртуальная машина вполне допустима и может оказаться очень практичной). Убедитесь, что на локальной машине установлен и работает openssh-сервер, а на удаленной машине установлен как минимум openssh-клиент.

11.9 Теперь запустите удаленную машину и соединитесь по `ssh` с локальным хостом. После установления соединения проверьте наличие сеансов `tmux`:

На удаленном хосте: `ssh local-username@local-ipaddress`. После подключения к локальной машине: `tmux ls`.

11.10 На удаленном хосте присоединитесь к сеансу **ssh** по имени:

```sh
tmux a -t ssh 
```
(`a` можно заменить на `at` или `attach`).

11.11 Вернувшись на локальную машину, подключитесь к сеансу **ssh** по имени, убедившись, что соединение с удаленным узлом сначала прервано:

```sh
tmux a -d -t ssh
``` 
(`a` можно заменить на `at` или `attach`).

11.12 Пусть все сессии отображаются для выбора, перейдите к первой сессии `[0]`. Там убейте сессию **ssh** по имени:

Набираем `Ctrl + b - s` , клавишами со стрелками отмечаем сессию `0` и нажимаем `Enter` 
```sh
tmux kill-session -t ssh
```

11.13 Наконец, отсоединиться от текущей сессии и убить ее по имени:

```sh
Ctrl + b - d 
tmux kill-session -t 0
```
---
12. Режим копирования в screen
При переходе в режим копирования в экран можно использовать не только клавиши со стрелками и `PgUp` или `PgDown` для перемещения по текущему окну и буферу прокрутки. Имеется также возможность использования `vi`-подобного полноэкранного редактора. Используя этот редактор, выполните следующие задачи:

12.1 Запустите `screen` 
12.2 Наберите в экранном терминале

```sh
echo supercalifragilisticexpialidocious
```

12.3 Теперь скопируйте пять последовательных символов (слева направо) в строке, расположенной прямо над курсором:

Входим в режим копирования: `Ctrl + a - [` или `Ctrl + a - :`, а затем набираем команду **"copy"**. Затем переходим на строку выше с помощью `k` и нажимаем `пробел`, чтобы отметить начало выделения. Наконец, переместимся на четыре символа вперед с помощью `l` и снова нажмем `пробел`, чтобы отметить конец выделения.

12.4 Наконец, вставьте выделенное обратно в командную строку:

`Ctrl + a - ]`

---
13.  И `screen`, и `tmux` могут войти в режим командной строки через `командный префикс + :` (краткий пример с `tmux` мы уже рассматривали). Выполните некоторые исследования и следующие задачи в режиме командной строки:

13.1 Заставить `screen` войти в режим копирования:

`Ctrl + a - :` — затем мы набираем copy.

13.2 Заставить `tmux` переименовать текущее окно:

`Ctrl + b - :` — затем мы набираем rename-window.

13.3 Заставить `screen` закрыть все окна и завершить сеанс:

`Ctrl + a - :` — затем мы набираем quit.

13.4 Заставить `tmux` разделить панель на две части:

`Ctrl + b - :` — затем мы набираем split-window.

13.5 Заставить `tmux` убить текущее окно:

`Ctrl + b - :` — затем мы набираем kill-window.

---