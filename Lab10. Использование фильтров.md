# 3. Команды GNU и UNIX

## 3.2 Использование фильтров при работе с текстовым потоком (103.2 Process text streams using filters)

---
### Практические задания
1. У вас есть ноутбук, и теперь вы хотите установить на него Linux. Руководства нет, и вам пришлось загружать его с USB-накопителя без какой-либо графики. Вы получаете терминальную оболочку и знаете, что для каждого процессора в файле **/proc/cpuinfo** найдется своя строка:
```console
processor : 0
vendor_id : GenuineIntel
cpu family : 6
model : 158
(lines skipped)
processor : 1
vendor_id : GenuineIntel
cpu family : 6
model : 158
(more lines skipped)
```
1.1 Просмотрите содержимое файла **/proc/cpuinfo**
```sh
cat /proc/cpuinfo
``` 

1.2 С помощью команд `grep` и `wc` узнайте, сколько у вас процессоров. 
```sh
cat /proc/cpuinfo | grep processor | wc -l 
``` 
и
```sh
grep processor /proc/cpuinfo | wc -l
``` 
Теперь, когда вы знаете, что есть несколько способов сделать одно и то же, когда следует использовать тот или иной? Это зависит от нескольких факторов, два из которых наиболее важны - производительность и читабельность. Чаще всего для автоматизации задач вы будете использовать команды оболочки внутри сценариев оболочки, и чем больше и сложнее становятся ваши сценарии, тем больше вам нужно заботиться об их быстродействии.

1.3 Сделайте то же самое с помощью `sed` вместо `grep` 

```sh
sed -n /processor/p /proc/cpuinfo | wc -l 
```
Здесь мы использовали `sed` с параметром `-n`, поэтому `sed` не будет печатать ничего, кроме того, что соответствует выражению "processor", как указано в команде "**p**". Как и в случае с `grep`, `wc -l` подсчитает количество строк, а значит, и количество имеющихся процессоров. 

1.4 Сделайте то же самое с помощью только `sed`  
```sh
sed -n /processor/p /proc/cpuinfo | sed -n '$='
``` 

Эта последовательность команд дает результаты, идентичные предыдущему примеру, где вывод `sed` был передан в команду `wc`. Разница заключается в том, что вместо использования команды `wc -l` для подсчета количества строк, снова вызывается `sed` для обеспечения эквивалентной функциональности. И снова мы подавляем вывод `sed` с помощью опции `-n`, за исключением выражения, которое мы явно вызываем, а именно `'$='`. Это выражение указывает sed на соответствие последней строке `$`, а затем на печать номера строки `=`.

---

2. Изучите локальный файл **/etc/passwd** с помощью команд `grep`, `sed`, `head` и `tail`.

2.1 Узнайте какие пользователи имеют доступ к оболочке Bash. Используйте `grep`.
```sh
grep ":/bin/bash$" /etc/passwd
```
2.2 Улучшите этот ответ, отображая только имя пользователя, использующего Bash shell. 
```sh
grep ":/bin/bash$" /etc/passwd | cut -d: -f1
```
Имя пользователя является первым полем (параметр `-f1` команды `cut`), а в файле **/etc/passwd** в качестве разделителей используются символы `:` (параметр `-d:` команды `cut`), мы просто передаем вывод команды `grep` в соответствующую команду `cut`.

2.3 В вашей системе есть различные пользователи, которые существуют для работы с определенными программами или для административных целей. Они не имеют доступа к оболочке. Узнайте сколько таких пользователей существует в вашей системе.

Самый простой способ узнать это - распечатать строки для учетных записей, не использующих оболочку Bash shell:
```sh
grep -v ":/bin/bash$" /etc/passwd | wc -l
```

2.4 Узнайте сколько пользователей и групп существует в вашей системе (помните: используйте только файл **/etc/passwd**)
  
Первое поле любой строки файла **/etc/passwd** - это имя пользователя, второе - это как правило, символ `x`, указывающий на то, что пароль пользователя здесь не хранится (он зашифрован в файле **/etc/shadow**). Третье - это идентификатор пользователя **UID**, а четвертое - идентификатор группы `GID`. Таким образом уточните количество пользователей:
```sh
cut -d: -f3 /etc/passwd | wc -l
```

В большинстве случаев так и будет. Однако бывают ситуации, когда необходимо задать различных суперпользователей или других специальных типов пользователей, имеющих один и тот же UID (user id). Поэтому, чтобы подстраховаться, мы передадим результат команды `cut` в команду `sort`, а затем подсчитаем количество строк.
```sh
cut -d: -f3 /etc/passwd | sort -u | wc -l
```
2.5 Теперь узнайте количество групп:
```sh
cut -d: -f4 /etc/passwd | sort -u | wc -l
```

2.6 Перечислите только первую, последнюю и десятую строки файла **/etc/passwd**.

```sh
sed -n -e '1'p -e '10'p -e '$'p /etc/passwd
```

Помните, что параметр `-n` указывает `sed` не печатать ничего, кроме того, что задано командой `p`. Используемый здесь знак доллара `$` представляет собой регулярное выражение, означающее последнюю строку файла.



---
3. Рассмотрим пример файла **/etc/passwd**. Скопируйте приведенные ниже строки в локальный файл с именем **mypasswd** для данного упражнения. Используйте `nano mypasswd` или `vim mypasswd`
```json
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
dave:x:1001:1000:Dave Edwards,Finance,,,Main Office:/home/dave:/bin/ksh
emma:x:1002:1000:Emma Jones,Finance,,,Main Office:/home/emma:/bin/bash
frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash
```

3.1 Перечислите всех пользователей группы **1000** (используйте `sed` для выбора только соответствующего поля) из вашего **mypasswd**: **GID** - это четвертое поле в файле **/etc/passwd**. Для начала попробуйте следующую команду:

```sh
sed -n /1000/p mypasswd
```

В этом случае вы также получите эту строку:
```json
carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
```

3.2 Решение выше - неверно, поскольку Кэрол Смит является членом **GID 2000**, а совпадение произошло из-за **UID**. Однако вы могли заметить, что после **GID** следующее поле начинается с символа верхнего регистра. Для решения этой проблемы используйте регулярное выражение.
```sh
sed -n /:1000:[A-Z]/p mypasswd
```
Выражение `[A-Z]` будет соответствовать любому одиночному символу верхнего регистра.

3.3 Перечислите только полные имена всех пользователей этой группы (используйте `sed` и `cut`):

Используйте ту же технику, которую вы использовали для решения первой части этого упражнения, и переведите ее в команду `cut`.

```sh
sed -n /:1000:[A-Z]/p mypasswd | cut -d: -f5
```
Вы получите результат:
```json
Dave Edwards,Finance,,,Main Office
Emma Jones,Finance,,,Main Office
Frank Cassidy,Finance,,,Main Office
Grace Kearns,Engineering,,,Main Office
Henry Adams,Sales,,,Main Office
John Chapel,Sales,,,Main Office
```

3.4 Обратите внимание, что поля внутри результатов могут быть разделены символом `,`. Поэтому передайтье вывод в другую команду `cut`, используя символ `,` в качестве разделителя.

```sh
sed -n /:1000:[A-Z]/p mypasswd | cut -d: -f5 | cut -d, -f1
```
Вы получите результат:
```json
Dave Edwards
Emma Jones
Frank Cassidy
Grace Kearns
Henry Adams
John Chapel
```

---
4. Еще раз, используя файл **mypasswd** из предыдущих упражнений, разработайте команду,которая будет выбирать одного человека из **Main Office** для победы в лотерее. Используйте команду `sed`, чтобы вывести только строки для Main Office, а затем последовательность команд `cut` для извлечения из этих строк имени каждого пользователя. Далее необходимо произвольно отсортировать эти имена и распечатать только первое имя из списка.

4.1 Сначала изучите, как параметр `-R` управляет выводом команды `sort`. Повторите эту команду несколько раз на своей машине (обратите внимание, что вам нужно заключить `'Main Office'` в одинарные кавычки, чтобы `sed` обработал команду `sort` как одиночную строку):

```sh
sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f1 | sort -R
```

4.2 Вы получили список, но авм нужна только одна строка. Исправьте свою команду следующим образом:

```sh
sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f1 | sort -R | head -1
```

---
5. Узнайте сколько человек работает в сфере финансов, инжиниринга и продаж? (Рассмотрим возможность изучения команды `uniq`).
   
5.1 Продолжайте развивать то, что вы узнали из предыдущих упражнений. Выполните следующие задания:

```sh
sed -n /'Main Office'/p mypasswd
```

```sh
sed -n /'Main Office'/p mypasswd | cut -d, -f2
```

5.2 Обратите внимание, что теперь нам не важен символ `:` в качестве разделителя. Нам просто нужно второе поле, когда мы разделяем строки символами `,`.
```sh
sed -n /'Main Office'/p mypasswd | cut -d, -f2 | uniq -c
```
получаем результат:
```json
4 Finance
1 Engineering
2 Sales
```
Команда `uniq` выводит только уникальные строки (не повторяющиеся), а параметр `-c` указывает команде `uniq` подсчитывать количество повторений одинаковых строк. Здесь есть оговорка: `uniq` будет учитывать только смежные линии. Если это не так, то необходимо использовать команду `sort`.

5.3 Теперь необходимо подготовить файл CSV (значения, разделенные запятыми), чтобы можно было легко импортировать из файла **mypasswd** из предыдущего примера, файл **names.csv** в LibreOffice. Файл будет иметь следующий формат:
```json
First Name,Last Name,Position
Carol,Smith,Finance
...
John,Chapel,Sales
```
> Совет: Для достижения желаемых результатов используйте команды `sed`, `cut` и `paste`. Обратите внимание, что запятая `,` будет являться разделителем для этого файла.

Начните с команд `sed` и `cut`, опираясь на то, что мы узнали из предыдущих упражнений. Создайте файл **firstname** с именами наших сотрудников.
```sh
sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d" " -f1 > firstname
```

5.4 Создайте файл **lastname**, содержащий фамилии каждого сотрудника.
```sh
sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d" " -f2 | cut -d, -f1 > lastname
```

5.5 Далее определите, в каком отделе работает каждый сотрудник:
```sh
sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f2 > department
```

5.6 Прежде чем приступить к работе над окончательным решением, выполните следующие команды и посмотрите, какие выходные данные они выдают:
```sh
cat firstname lastname department
```
```sh
paste firstname lastname department
```

5.7 А теперь - окончательное решение:
```sh
paste firstname lastname department | tr '\t' ,
```
сохраните вывод в файл:
```sh
paste firstname lastname department | tr '\t' , > names.csv
```
```sh
cat names.csv
```
Здесь мы используем команду `tr` для перевода `\t`, разделителя табуляции, на символ `,`, когда нужно заменить один символ на другой. 

5.8 Просмотрите man-страницы для команд `tr` и `paste`. Например, мы можем использовать опцию `-d` для разделителя, чтобы сделать предыдущую команду менее сложной:
```sh
paste -d, firstname lastname department
```

5.9 Мы использовали здесь команду `paste`, чтобы познакомить вас с ней. Однако можно было легко выполнить все задачи в одной цепочке команд:
```sh
sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f1,2 | tr ' ' , > names.csv
```
```sh
cat names.csv
```

---
6. Предположим, что электронная таблица **names.csv**, созданная в предыдущем упражнении, является важным файлом и мы хотим быть уверены, что никто не сможет ее подделать с момента отправки и до момента получения адресатом. Как мы можем обеспечить целостность этого файла с помощью md5sum?

Если заглянуть на man-страницы для `md5sum`, `sha256sum` и `sha512sum`, то можно увидеть, что все они начинаются со следующего текста: “compute and check XXX message digest”. Где "**XXX**" - это алгоритм, который будет использоваться для создания дайджеста сообщения.

6.1 В качестве примера мы будем использовать `md5sum`, а в дальнейшем вы сможете попробовать использовать и другие команды.
```sh
md5sum names.csv
```
ваша контрольная сумма может отличаться от приведенной в примере
```console
61f0251fcab61d9575b1d0cbf0195e25 names.csv
```

6.2 Теперь, например, вы можете сделать файл доступным через защищенную службу **ftp** и отправить сгенерированную контрольную сумму с помощью другого защищенного средства связи. Если файл был слегка изменен, то контрольная сумма будет совершенно другой. 

Чтобы убедиться в этом, отредактируйте файл **names.csv** и замените Jones на James, как показано здесь:
```sh
sed -i.backup s/Jones/James/ names.csv
```
Теперь снова вычислите контрольную сумму - она должна отличаться от полученной на предыдущем шаге
```sh
md5sum names.csv
```
```console
f44a0d68cb480466099021bf6d6d2e65 names.csv
```

6.3 Когда вы предоставляете файлы для загрузки, всегда полезно опубликовать контрольную сумму  (message digest), чтобы люди, скачавшие ваш файл, могли составить новый message digest (контрольную сумму) и сверить его с оригиналом. 
Просмотрите сайт https://kernel.org, найдите страницу https://mirrors.edge.kernel.org/pub/linux/kernel/v6.x/sha256sums.asc, где можно получить сумму **sha256sum** для всех файлов, доступных для загрузки.

6.4 Скачайте файл https://mirrors.edge.kernel.org/pub/linux/kernel/v6.x/sha256sums.asc и любой файл из каталога https://mirrors.edge.kernel.org/pub/linux/kernel/v6.x/

6.5 Сравните контрольную сумму скачаного файла с контрольной суммой,  приведенной для этого файла в списке sha256sums.asc


---
7. Вы пообещали себе, что будете читать классическую книгу по 100 строк в день, и решили начать с "Моряка и мистика" Германа Мелвилла. Придумайте команду с использованием `split`, которая разделит эту книгу на части по 100 строк в каждой. Для того чтобы получить книгу в формате обычного текста, найдите ее по адресу https://www.gutenberg.org.

7.1 Сначала мы возьмите всю книгу с сайта Project Gutenberg, где можно получить эту и другие книги, находящиеся в открытом доступе.
```sh
wget https://www.gutenberg.org/files/50461/50461-0.txt
```

Возможно, потребуется установить `wget`, если он еще не установлен в вашей системе. В качестве альтернативы можно можно использовать `curl`. 

7.2 Для проверки книги используйте `less`:
```sh
$ less 50461-0.txt
```

7.3 Теперь разобейте книгу на фрагменты по 100 строк в каждом:
```sh
$ split -l 100 -d 50461-0.txt melville
```

`50461-0.txt` - это файл, который мы будем разделять. `melville` - это префикс для разделяемых файлов. Параметр `-l 100` задает количество строк, а опция `-d` указывает программе `split` на нумерацию файлов (с использованием указанный суффикс). Вы можете использовать `nl` для любого из разделенных файлов (возможно, не для последнего)
и убедиться, что каждый из них содержит 100 строк.


---
8. Модифицируйте результат команды `ls -l` в каталоге **/etc**: используя команду `cut` выведите на экран только имена файлов, выведите на экран  имя файла и владельца файлов? 

8.1 Наряду с командами `ls -l` и `cut` можно использовать команду `tr` для сжатия нескольких пробелов в один пробел, чтобы облегчить форматирование вывода командой `cut`.

Команда `ls` сама по себе выдает только имена файлов. Однако мы можем использовать вывод команды `ls -l` (длинный листинг) для получения более конкретной информации.
```sh
ls -l /etc | tr -s ' ' ,
```
```
drwxr-xr-x,3,root,root,4096,out,24,16:58,acpi
-rw-r--r--,1,root,root,3028,dez,17,2018,adduser.conf
-rw-r--r--,1,root,root,10,out,2,17:38,adjtime
drwxr-xr-x,2,root,root,12288,out,31,09:40,alternatives
-rw-r--r--,1,root,root,401,mai,29,2017,anacrontab
-rw-r--r--,1,root,root,433,out,1,2017,apg.conf
drwxr-xr-x,6,root,root,4096,dez,17,2018,apm
drwxr-xr-x,3,root,root,4096,out,24,16:58,apparmor
drwxr-xr-x,9,root,root,4096,nov,6,20:20,apparmor.d
```
Параметр `-s` указывает команде `tr` сжать повторяющиеся пробелы в один экземпляр пробела. Команда `tr` работает с любым типом повторяющегося символа, который вы укажете. Затем мы заменяем пробелы на запятую `,`. 

8.2 В нашем примере замена пробелов не требуется, поэтому просто опустите символ `,`.
```sh
ls -l /etc | tr -s ' '
```
```
drwxr-xr-x 3 root root 4096 out 24 16:58 acpi
-rw-r--r-- 1 root root 3028 dez 17 2018 adduser.conf
-rw-r--r-- 1 root root 10 out 2 17:38 adjtime
drwxr-xr-x 2 root root 12288 out 31 09:40 alternatives
-rw-r--r-- 1 root root 401 mai 29 2017 anacrontab
-rw-r--r-- 1 root root 433 out 1 2017 apg.conf
drwxr-xr-x 6 root root 4096 dez 17 2018 apm
drwxr-xr-x 3 root root 4096 out 24 16:58 apparmor
```

8.3 Если нужны только имена файлов, то выводить нужно только девятое поле:
```sh
$ ls -l /etc | tr -s ' ' | cut -d" " -f9
```

8.4 Для указания имени файла и его владельца нам понадобятся девятое и третье поля:
```sh
$ ls -l /etc | tr -s ' ' | cut -d" " -f9,3
```

8.5 Если нам нужны только имена папок и их владельцы, то выполните следующую команду:
```sh
$ ls -l /etc | grep ^d | tr -s ' ' | cut -d" " -f9,3
```

---
9. Это упражнение предполагает, что вы находитесь на реальной машине (не виртуальной). Также необходимо иметь при себе USB-накопитель. 

9.1 Просмотрите страницы руководства по команде `tail` и выясните, как следить за файлом, когда к нему добавляется текст. 

9.2 Наблюдая за выводом команды `tail` в файле /var/log/syslog, вставьте USB-накопитель. 

9.3 Запишите полную команду, которую вы бы использовали для получения Product, Manufacturer и общий объем памяти вашего USB-накопителя.
```sh
tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'
```
```console
Nov 8 06:01:35 brod-avell kernel: [124954.369361] usb 1-4.3: Product: Cruzer Blade
Nov 8 06:01:35 brod-avell kernel: [124954.369364] usb 1-4.3: Manufacturer: SanDisk
Nov 8 06:01:37 brod-avell kernel: [124955.419267] sd 2:0:0:0: [sdc] 61056064 512-byte
logical blocks: (31.3 GB/29.1 GiB)
```

Разумеется, это пример, и результаты могут отличаться в зависимости от производителя USB-накопителя. Обратите внимание, что теперь мы используем параметр `-i` в команде `grep`, так как мы не уверены, что искомые строки находятся в верхнем или нижнем регистре. Мы также использовали параметр `|` в качестве логического `ИЛИ`, поэтому мы ищем строки, содержащие product ИЛИ blocks ИЛИ manufacturer.