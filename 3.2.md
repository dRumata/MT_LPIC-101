# 103.2 Process text streams using filters

1. Кто-то подарил вашей школе ноутбук, и теперь вы хотите установить на него Linux. Руководства нет, и вам пришлось загружать его с USB-накопителя без какой-либо графики. Вы получаете терминальную оболочку и знаете, что для каждого процессора в файле **/proc/cpuinfo** найдется своя строка:
```console
processor : 0
vendor_id : GenuineIntel
cpu family : 6
model : 158
(lines skipped)
processor : 1
vendor_id : GenuineIntel
cpu family : 6
model : 158
(more lines skipped)
```
- С помощью команд `grep` и `wc` можно узнать, сколько у вас процессоров. Вот два варианта: 
```sh
$ cat /proc/cpuinfo | grep processor | wc -l 
$ grep processor /proc/cpuinfo | wc -l
``` 
Теперь, когда вы знаете, что есть несколько способов сделать одно и то же, когда следует использовать тот или иной? Это зависит от нескольких факторов, два из которых наиболее важны - производительность и читабельность. Чаще всего для автоматизации задач вы будете использовать команды оболочки внутри сценариев оболочки, и чем больше и сложнее становятся ваши сценарии, тем больше вам нужно заботиться об их быстродействии.

- Сделайте то же самое с помощью `sed` вместо `grep` 

Теперь вместо grep попробуем сделать это с помощью `sed`: 
```sh
$ sed -n /processor/p /proc/cpuinfo | wc -l 
```
Здесь мы использовали `sed` с параметром `-n`, поэтому `sed` не будет печатать ничего, кроме того, что соответствует выражению "processor", как указано в команде "**p**". Как и в случае с `grep`, `wc -l` подсчитает количество строк, а значит, и количество имеющихся процессоров. 

Рассмотрим следующий пример: 
```sh
$ sed -n /processor/p /proc/cpuinfo | sed -n '$='
``` 

Эта последовательность команд дает результаты, идентичные предыдущему примеру, где вывод `sed` был передан в команду `wc`. Разница заключается в том, что вместо использования команды `wc -l` для подсчета количества строк, снова вызывается `sed` для обеспечения эквивалентной функциональности. И снова мы подавляем вывод `sed` с помощью опции `-n`, за исключением выражения, которое мы явно вызываем, а именно `'$='`. Это выражение указывает sed на соответствие последней строке `$`, а затем на печать номера строки `=`.

2. Изучите локальный файл **/etc/passwd** с помощью команд `grep`, `sed`, `head` и `tail` в соответствии с приведенными ниже задачами:

- Какие пользователи имеют доступ к оболочке Bash?
```sh
$ grep ":/bin/bash$" /etc/passwd
```
Мы улучшим этот ответ, отображая только имя пользователя, использующего Bash shell. 
```sh
$ grep ":/bin/bash$" /etc/passwd | cut -d: -f1
```
Имя пользователя является первым полем (параметр `-f1` команды `cut`), а в файле **/etc/passwd** в качестве разделителей используются символы `:` (параметр `-d:` команды `cut`), мы просто передаем вывод команды `grep` в соответствующую команду `cut`.

- В вашей системе есть различные пользователи, которые существуют для работы с определенными программами или для административных целей. Они не имеют доступа к оболочке. Сколько таких пользователей существует в вашей системе?

Самый простой способ узнать это - распечатать строки для учетных записей, не использующих оболочку Bash shell:
```sh
$ grep -v ":/bin/bash$" /etc/passwd | wc -l
```

- Сколько пользователей и групп существует в вашей системе (помните: используйте только файл **/etc/passwd**)
  
Первое поле любой строки файла **/etc/passwd** - это имя пользователя, второе - это
как правило, символ `x`, указывающий на то, что пароль пользователя здесь не хранится (он зашифрован в файле **/etc/shadow**). Третье - это идентификатор пользователя **UID**, а четвертое - идентификатор группы `GID`. Таким образом должно дать нам количество пользователей:
```sh
$ cut -d: -f3 /etc/passwd | wc -l
```
В большинстве случаев так и будет. Однако бывают ситуации, когда необходимо задать различных суперпользователей или других специальных типов пользователей, имеющих один и тот же UID (user id). Поэтому, чтобы подстраховаться, мы передадим результат команды `cut` в команду `sort`, а затем подсчитаем количество строк.
```sh
$ cut -d: -f3 /etc/passwd | sort -u | wc -l
```

Теперь о количестве групп:
```sh
$ cut -d: -f4 /etc/passwd | sort -u | wc -l
```

- Перечислите только первую, последнюю и десятую строки файла **/etc/passwd**.

Это можно выполнить следующей командой:
```sh
$ sed -n -e '1'p -e '10'p -e '$'p /etc/passwd
```

Помните, что параметр `-n` указывает `sed` не печатать ничего, кроме того, что задано командой `p`. Используемый здесь знак доллара `$` представляет собой регулярное выражение, означающее последнюю строку файла.

3. Рассмотрим пример файла **/etc/passwd**. Скопируйте приведенные ниже строки в локальный файл с именем **mypasswd** для данного упражнения.
```json
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
dave:x:1001:1000:Dave Edwards,Finance,,,Main Office:/home/dave:/bin/ksh
emma:x:1002:1000:Emma Jones,Finance,,,Main Office:/home/emma:/bin/bash
frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash
```

- Перечислите всех пользователей группы **1000** (используйте `sed` для выбора только соответствующего поля) из вашего **mypasswd**:

**GID** - это четвертое поле в файле **/etc/passwd**. Может возникнуть соблазн попробовать следующее:

```sh
$ sed -n /1000/p mypasswd
```

В этом случае вы также получите эту строку:
```json
carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
```

Вы знаете, что это неверно, поскольку Кэрол Смит является членом **GID 2000**, а совпадение произошло из-за **UID**. Однако вы могли заметить, что после **GID** следующее
поле начинается с символа верхнего регистра. Для решения этой проблемы мы можем использовать регулярное выражение.
```sh
$ sed -n /:1000:[A-Z]/p mypasswd
```
Выражение `[A-Z]` будет соответствовать любому одиночному символу верхнего регистра. Более подробно об этом вы узнаете в соответствующем уроке.

- Перечислите только полные имена всех пользователей этой группы (используйте `sed` и `cut`):

Используйте ту же технику, которую вы использовали для решения первой части этого упражнения, и переведите ее в команду `cut`.

```sh
$ sed -n /:1000:[A-Z]/p mypasswd | cut -d: -f5

Dave Edwards,Finance,,,Main Office
Emma Jones,Finance,,,Main Office
Frank Cassidy,Finance,,,Main Office
Grace Kearns,Engineering,,,Main Office
Henry Adams,Sales,,,Main Office
John Chapel,Sales,,,Main Office
```

Не совсем так! Обратите внимание, что поля внутри результатов могут быть разделены символом `,`. Поэтому мы передадим вывод в другую команду `cut`, используя символ `,` в качестве разделителя.

```sh
$ sed -n /:1000:[A-Z]/p mypasswd | cut -d: -f5 | cut -d, -f1

Dave Edwards
Emma Jones
Frank Cassidy
Grace Kearns
Henry Adams
John Chapel

```

4. Еще раз, используя файл **mypasswd** из предыдущих упражнений, разработайте команду,которая будет выбирать одного человека из Main Office для победы в лотерее. Используйте команду `sed`, чтобы вывести только строки для Main Office, а затем последовательность команд `cut` для извлечения из этих строк имени каждого пользователя. Далее необходимо произвольно отсортировать эти имена и распечатать только первое имя из списка.

Сначала изучите, как параметр `-R` управляет выводом команды `sort`. Повторите эту
команду несколько раз на своей машине (обратите внимание, что вам нужно заключить `'Main Office'` в одинарные кавычки, чтобы `sed` обработал команду `sort` как одиночную строку):

```sh
$ sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f1 | sort -R
```

Вот решение этой проблемы:

```sh
$ sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f1 | sort -R | head -1
```

5. Сколько человек работает в сфере финансов, инжиниринга и продаж? (Рассмотрим возможность изучения команды `uniq`).
   
Продолжайте развивать то, что вы узнали из предыдущих упражнений. Попробуйте выполнить следующие задания:

```sh
$ sed -n /'Main Office'/p mypasswd
$ sed -n /'Main Office'/p mypasswd | cut -d, -f2
```

Обратите внимание, что теперь нам не важен символ `:` в качестве разделителя. Нам просто нужно второе поле, когда мы разделяем строки символами `,`.
```sh
$ sed -n /'Main Office'/p mypasswd | cut -d, -f2 | uniq -c
4 Finance
1 Engineering
2 Sales
```
Команда `uniq` выводит только уникальные строки (не повторяющиеся), а параметр
параметр `-c` указывает команде `uniq` подсчитывать количество повторений одинаковых строк. Здесь есть оговорка: `uniq` будет учитывать только смежные линии. Если это не так, то необходимо использовать команду `sort`.

Теперь необходимо подготовить файл CSV (значения, разделенные запятыми), чтобы можно было легко импортировать из файла **mypasswd** из предыдущего примера, файл **names.csv** в LibreOffice. Файл будет иметь следующий формат:
```json
First Name,Last Name,Position
Carol,Smith,Finance
...
John,Chapel,Sales
```
> Совет: Для достижения желаемых результатов используйте команды `sed`, `cut` и `paste`. Обратите внимание, что запятая `,` будет являться разделителем для этого файла.

Начните с команд `sed` и `cut`, опираясь на то, что мы узнали из предыдущих упражнений:
```sh
$ sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d" " -f1 > firstname
```

Теперь у нас есть файл **firstname** с именами наших сотрудников.

```sh
$ sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d" " -f2 | cut -d, -f1 > lastname
```

Теперь у нас есть файл **lastname**, содержащий фамилии каждого сотрудника.

Далее мы определяем, в каком отделе работает каждый сотрудник:
```sh
$ sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f2 > department
```
Прежде чем приступить к работе над окончательным решением, попробуйте выполнить следующие команды и посмотреть, какие выходные данные они выдают:
```sh
$ cat firstname lastname department
$ paste firstname lastname department
```

А теперь - окончательное решение:
```sh
$ paste firstname lastname department | tr '\t' ,
$ paste firstname lastname department | tr '\t' , > names.csv
```

Здесь мы используем команду `tr` для перевода `\t`, разделителя табуляции, на символ `,`, когда нужно заменить один символ на другой. Обязательно просмотрите man-страницы для команд `tr` и `paste`. Например, мы можем использовать опцию `-d` для разделителя, чтобы сделать предыдущую команду менее сложной:
```sh
$ paste -d, firstname lastname department
```

Мы использовали здесь команду `paste` один раз, чтобы познакомить вас с ней. Однако мы
мы могли бы легко выполнить все задачи в одной цепочке команд:
```sh
$ sed -n /'Main Office'/p mypasswd | cut -d: -f5 | cut -d, -f1,2 | tr ' ' , > names.csv
```

6. Предположим, что электронная таблица **names.csv**, созданная в предыдущем упражнении, является важным файлом и мы хотим быть уверены, что никто не сможет ее подделать с момента отправки и до момента получения адресатом. Как мы можем обеспечить целостность этого файла с помощью md5sum?

Если заглянуть на man-страницы для `md5sum`, `sha256sum` и `sha512sum`, то можно увидеть, что все они начинаются со следующего текста: “compute and check XXX message digest”. Где "**XXX**" - это алгоритм, который будет использоваться для создания дайджеста сообщения.

В качестве примера мы будем использовать `md5sum`, а в дальнейшем вы сможете попробовать использовать и другие команды.
```sh
$ md5sum names.csv
61f0251fcab61d9575b1d0cbf0195e25 names.csv
```

Теперь, например, вы можете сделать файл доступным через защищенную службу **ftp** и отправить сгенерированную контрольную сумму с помощью другого защищенного средства связи. Если файл был слегка изменен, то контрольная сумма будет совершенно другой. Чтобы убедиться в этом, отредактируйте файл **names.csv** и замените Jones на James, как показано здесь:
```sh
$ sed -i.backup s/Jones/James/ names.csv
$ md5sum names.csv
f44a0d68cb480466099021bf6d6d2e65 names.csv
```
Когда вы предоставляете файлы для загрузки, всегда полезно опубликовать контрольную сумму
(message digest), чтобы люди, скачавшие ваш файл, могли составить новый message digest (контрольную сумму) и сверить его с оригиналом. Если вы просмотрите сайт https://kernel.org, то найдете
страницу https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/sha256sums.asc, где можно
получить сумму **sha256sum** для всех файлов, доступных для загрузки.

7. Вы пообещали себе, что будете читать классическую книгу по 100 строк в день, и решили начать с "Моряка и мистика" Германа Мелвилла. Придумайте команду с использованием `split`, которая разделит эту книгу на части по 100 строк в каждой. Для того чтобы получить книгу в формате обычного текста, найдите ее по адресу https://www.gutenberg.org.

Сначала мы возьмем всю книгу с сайта Project Gutenberg, где можно получить эту и другие книги, находящиеся в открытом доступе.
```sh
$ wget https://www.gutenberg.org/files/50461/50461-0.txt
```

Возможно, потребуется установить `wget`, если он еще не установлен в вашей системе. В качестве альтернативы можно можно использовать `curl`. Для проверки книги используйте `less`:
```sh
$ less 50461-0.txt
```

Теперь мы разобьем книгу на фрагменты по 100 строк в каждом:
```sh
$ split -l 100 -d 50461-0.txt melville
```
`50461-0.txt` - это файл, который мы будем разделять. `melville` - это префикс для разделяемых файлов. Параметр `-l 100` задает количество строк, а опция `-d` указывает программе `split` на нумерацию файлов (с использованием указанный суффикс). Вы можете использовать `nl` для любого из разделенных файлов (возможно, не для последнего)
и убедиться, что каждый из них содержит 100 строк.

8. При использовании команды `ls -l` в каталоге **/etc**, какой вид листинга вы получите? Используя команду `cut` как вывести на экран только имена файлов? Что можно сделать с именем файла и владельцем файлов? 

Наряду с командами `ls -l` и `cut` можно использовать команду `tr` для сжатия нескольких пробелов в один пробел, чтобы облегчить форматирование вывода командой `cut`.

Команда `ls` сама по себе выдает только имена файлов. Однако мы можем использовать вывод команды `ls -l` (длинный листинг) для получения более конкретной информации.
```sh
$ ls -l /etc | tr -s ' ' ,

drwxr-xr-x,3,root,root,4096,out,24,16:58,acpi
-rw-r--r--,1,root,root,3028,dez,17,2018,adduser.conf
-rw-r--r--,1,root,root,10,out,2,17:38,adjtime
drwxr-xr-x,2,root,root,12288,out,31,09:40,alternatives
-rw-r--r--,1,root,root,401,mai,29,2017,anacrontab
-rw-r--r--,1,root,root,433,out,1,2017,apg.conf
drwxr-xr-x,6,root,root,4096,dez,17,2018,apm
drwxr-xr-x,3,root,root,4096,out,24,16:58,apparmor
drwxr-xr-x,9,root,root,4096,nov,6,20:20,apparmor.d
```
Параметр `-s` указывает команде `tr` сжать повторяющиеся пробелы в один экземпляр пробела. Команда `tr` работает с любым типом повторяющегося символа, который вы укажете. Затем мы заменяем пробелы на запятую `,`. В нашем примере замена пробелов не требуется, поэтому мы просто опустим символ `,`.
```sh
$ ls -l /etc | tr -s ' '
drwxr-xr-x 3 root root 4096 out 24 16:58 acpi
-rw-r--r-- 1 root root 3028 dez 17 2018 adduser.conf
-rw-r--r-- 1 root root 10 out 2 17:38 adjtime
drwxr-xr-x 2 root root 12288 out 31 09:40 alternatives
-rw-r--r-- 1 root root 401 mai 29 2017 anacrontab
-rw-r--r-- 1 root root 433 out 1 2017 apg.conf
drwxr-xr-x 6 root root 4096 dez 17 2018 apm
drwxr-xr-x 3 root root 4096 out 24 16:58 apparmor
```

Если мне нужны только имена файлов, то выводить нужно только девятое поле:
```sh
$ ls -l /etc | tr -s ' ' | cut -d" " -f9
```

Для указания имени файла и его владельца нам понадобятся девятое и третье поля:
```sh
$ ls -l /etc | tr -s ' ' | cut -d" " -f9,3
```

А если нам нужны только имена папок и их владельцы?
```sh
$ ls -l /etc | grep ^d | tr -s ' ' | cut -d" " -f9,3
```

9. Это упражнение предполагает, что вы находитесь на реальной машине (не виртуальной). Также необходимо иметь при себе USB-накопитель. Просмотрите страницы руководства по команде `tail` и выясните, как следить за файлом, когда к нему добавляется текст. Наблюдая за выводом команды `tail` в файле /var/log/syslog, вставьте USB-накопитель. Запишите полную команду, которую вы бы использовали для получения Product, Manufacturer и общий объем памяти вашего USB-накопителя.
```sh
$ tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'
Nov 8 06:01:35 brod-avell kernel: [124954.369361] usb 1-4.3: Product: Cruzer Blade
Nov 8 06:01:35 brod-avell kernel: [124954.369364] usb 1-4.3: Manufacturer: SanDisk
Nov 8 06:01:37 brod-avell kernel: [124955.419267] sd 2:0:0:0: [sdc] 61056064 512-byte
logical blocks: (31.3 GB/29.1 GiB)
```

Разумеется, это пример, и результаты могут отличаться в зависимости от производителя USB-накопителя. Обратите внимание, что теперь мы используем параметр `-i` в команде `grep`, так как мы не уверены, что искомые строки находятся в верхнем или нижнем регистре. Мы также использовали параметр `|` в качестве логического `ИЛИ`, поэтому мы ищем строки, содержащие product ИЛИ blocks ИЛИ manufacturer.