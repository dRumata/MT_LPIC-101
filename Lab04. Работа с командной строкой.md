## Практическая работа 4. 
## Загрузка системы.

# 3. Команды GNU и UNIX

## 3.1 Работа с командной строкой (103.1 Work on the command line)

### Вопросы для самопроверки

1. С помощью системы `man` можно определить, как указать команде `apropos` на вывод краткой команды, чтобы она выводила только краткое сообщение об использовании, а затем выходила из программы. 
    <details>
    <summary>Вариант ответа</summary>

    Запустите 
    ```
    man apropos
    ``` 
    и прокрутите вниз раздел "**Options**", пока не доберетесь до параграфа **--usage**.
    
    </details>
<br> 


2. С помощью системы `man` можно определить, какая лицензия на авторские права закреплена за командой `grep`. 
    <details>
    <summary>Вариант ответа</summary>

    Запустите 
    ```
    man grep
    ``` 
    и прокрутите страницу вниз до раздела "**Copyright**". Обратите внимание, что программа использует авторское право Free Software Foundation.

    </details>
<br> 


---
### Практические задания

1. Определите архитектуру аппаратного обеспечения и версию ядра **Linux**, используемого на вашем компьютере, в удобном для восприятия формате. 

1.1 Запустите справку по команде uname
```sh
man uname
```
1.2 прочитайте раздел "Описание" и определите аргументы команды, которые позволят вывести только те результаты, которые вам нужны. 

1.3 Обратите внимание, что параметр `-v` выводит версию ядра, а `-i` - аппаратную платформу.
```sh
$ man uname
$ uname -v
$ uname -i
```

---
2. Выведите последние двадцать строк динамической базы данных истории и файла **.bash_history** для их сравнения.
```sh
$ history 20
$ tail -n 20 .bash_history
```

---
3. С помощью инструмента `apropos` найдите **man**-страницу, на которой находится команда, необходимая для отображения размера подключенного физического блочного устройства в байтах, а не в мегабайтах или гигабайтах. 

3.1 Запустить `apropos` со строкой `block`, прочитать результаты, 
```sh
$ apropos block
```
3.2 Заметьте, что `lsblk` перечисляет блочные устройства (и, следовательно, является наиболее подходящим инструментом для наших нужд), выполните
```sh
man lsblk
```
3.3 Пролистайте раздел "Описание" и заметьте, что `-b` отображает размер устройства в байтах. Наконец, выполните команду 
```sh
lsblk -b
```
и посмотрите, что получится.

---
4. Измените пути поиска исполняемых файлов и скриптов.
4.1  Временно добавьте новый каталог (с именем **myfiles**, который находится в вашем домашнем каталоге) в переменную PATH с помощью команды 
```sh
mkdir ~/myfiles
export PATH="/home/yourname/myfiles:$PATH"
```

4.2 Создайте простой скрипт в каталоге **myfiles/**, сделайте его исполняемым и попробуйте запустить его из другого каталога. Эти команды предполагают, что вы находитесь в своем домашнем каталоге, который содержит каталог **myfiles**.
```sh
$ touch myfiles/myscript.sh
$ echo '#!/bin/bash' >> myfiles/myscript.sh
$ echo 'echo Hello' >> myfiles/myscript.sh
$ chmod +x myfiles/myscript.sh
$ myscript.sh 
Hello
```

---
5. Используйте команду `unset` для удаления переменной PATH. 

5.1 Ввод команды 
```sh
unset PATH 
```
приведет к стиранию текущих настроек пути. 

5.2 Попробуйте выполнить команду  используя sudo. 
```sh
sudo cat /etc/shadow
```
 (Выход из оболочки вернет вас в исходное состояние). 

5.3 Попытка вызвать двоичный файл без его абсолютного адреса будет неудачной. По этой причине попытка выполнить команду с помощью `sudo` (которая сама является двоичной программой, расположенной в каталоге **/usr/bin/sudo**) будет неудачной, если не указать ее абсолютное местоположение. Попробуйте следующую команду:

```sh
/usr/bin/sudo /bin/cat /etc/shadow
```

5.4 Сбросить **PATH** можно с помощью export или просто выйдя из оболочки.
Выйдите из оболочки.

---
6. Попробуйте выполнить команды, используя строки, состоящие из специальных символов, и применяя различные методы их экранирования. Обратите внимание на различия в поведении этих методов? 

Экранирование с помощью символов `"` сохранит специальные значения знака доллара, обратного знака и обратной косой черты. Экранирование с помощью символа `'`, напротив, приведет к тому, что все символы будут считаться буквальными.
```sh
$ mynewvar=goodbye
$ echo "$mynewvar"
goodbye
$ echo '$mynewvar'
$mynewvar
```