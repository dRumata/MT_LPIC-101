# 4. Устройства, файловые системы, FHS
## 4.6 FHS, правила размещения файлов (104.7 Find system files and place files in the correct location) 

### Вопросы для самопроверки

1. Представьте, что программе необходимо создать одноразовый временный файл, который больше никогда не понадобится после закрытия программы. В каком каталоге будет правильно создать этот файл?

Поскольку после завершения работы программы файл нам не нужен, правильным каталогом будет **/tmp**.

2. Какой временный каталог должен быть очищен в процессе загрузки?

Это каталог **/run** или, в некоторых системах, **/var/run**.

3. Используя команду `find`, найдите только в текущем каталоге файлы, которые доступны пользователю на запись, были изменены за последние 10 дней и имеют размер более 4 Гбайт.

Для этого вам понадобятся параметры `-writable`, `-mtime` и `-size`: 

```sh
find . -writable -mtime -10 -size +4G
```

4. Используя `locate`, найдите все файлы, содержащие в своих именах оба шаблона **report** и либо **updated**, либо **update**, либо **update**.

Поскольку `locate` должен соответствовать всем шаблонам, используйте опцию `-A`:

```sh
locate -A "report" "updat"
```

5. Как найти, где хранится **manpage** для `ifconfig`?

Используйте параметр `-m` для `whereis`:

```sh
whereis -m ifconfig
```

6. Какую переменную необходимо добавить в файл **/etc/updatedb.conf**, чтобы `updatedb` игнорировал файловые системы **ntfs**?

Это переменная `PRUNEFS=`, за которой следует тип файловой системы: `PRUNEFS=ntfs`

7. Системный администратор хочет смонтировать внутренний диск **/dev/sdc1**. Согласно FHS, в каком каталоге должен быть смонтирован этот диск?

На практике диск может быть смонтирован в любом месте. Однако FHS рекомендует выполнять временное монтирование в каталоге **/mnt**

8. При использовании функции `locate` результаты поиска извлекаются из базы данных, формируемой программой `updatedb`. Однако эта база данных может быть устаревшей, что приводит к тому, что locate показывает файлы, которые уже не существуют. Как заставить `locate` показывать на выходе только существующие файлы?
   
Добавьте к `locate` параметр `-e`, как показано ниже 

```sh
locate -e PATTERN
```

9. Необходимо найти в текущем каталоге или в подкаталогах до двух уровней ниже, исключая смонтированные файловые системы, все файлы, в именах которых встречается шаблон **Status** или **statute**.
Помните, что для параметра `-maxdepth` необходимо учитывать и текущий каталог, поэтому мы хотим получить три уровня (текущий плюс 2 уровня вниз):

```sh
find . -maxdepth 3 -mount -iname "*statu*"
```

10. Если ограничить поиск файловыми системами ext4, то в каталоге **/mnt** будут найдены все файлы, которые имеют как минимум права на выполнение для данной группы, доступны для чтения текущему пользователю и у которых за последние 2 часа был изменен какой-либо атрибут.

Используйте параметр `-fstype` в команде `find`, чтобы ограничить поиск файловыми системами определенных типов. Файл, читаемый текущим пользователем, будет иметь не менее 4 в первом разряде разрешений, а исполняемый группой - не менее 1 во втором разряде. Поскольку нам не важны разрешения для других, мы можем использовать 0 для третьего разряда. Для фильтрации последних изменений атрибутов используйте параметр `-cmin N`, помня, что `N` указывается в минутах. Таким образом:

```sh
find /mnt -fstype ext4 -perm -410 -cmin -120
```

11.  Необходимо найти пустые файлы, которые были изменены более 30 дней назад и находятся не менее чем на два уровня ниже текущего каталога.

Параметр `-mindepth N` может быть использован для ограничения поиска не менее чем `N` уровнями ниже, но помните, что в подсчет необходимо включать текущий каталог. Параметр `-empty` используется для проверки пустых файлов, а `-mtime N` - для проверки времени модификации. Итак:

```sh
find . -empty -mtime +30 -mindepth 3
```

12. Предположим, что пользователи **Carol** и **john** входят в группу **mkt**. Найдите в домашнем каталоге Джона все файлы, которые также доступны для чтения Кэрол.
Учитывая, что они входят в одну группу, нам нужен хотя бы **r (4)** в групповых разрешениях, а остальные нас не волнуют. Итак:

```sh
find /home/john -perm -040
```